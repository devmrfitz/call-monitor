"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getKeyFingerprintSync = exports.getKeyFingerprint = exports.importKeySync = exports.importKey = exports.exportCryptoKey = exports.generateKey = exports.serializeKey = exports.parseKeySync = exports.parseKey = exports.formatKey = exports.cloakKeyRegex = exports.FINGERPRINT_LENGTH = void 0;
const codec_1 = require("@47ng/codec");
let nodeCrypto;
if (typeof window === 'undefined') {
    nodeCrypto = require('crypto');
}
exports.FINGERPRINT_LENGTH = 8;
exports.cloakKeyRegex = /^k1\.aesgcm256\.(?<key>[a-zA-Z0-9-_]{43}=?)$/;
function formatKey(raw) {
    return ['k1', 'aesgcm256', codec_1.b64.encode(raw)].join('.');
}
exports.formatKey = formatKey;
async function parseKey(key, usage) {
    return {
        raw: await importKey(key, usage),
        fingerprint: await getKeyFingerprint(key)
    };
}
exports.parseKey = parseKey;
/**
 * Sync version of parseKey, only available for Node.js
 */
function parseKeySync(key) {
    return {
        raw: importKeySync(key),
        fingerprint: getKeyFingerprintSync(key)
    };
}
exports.parseKeySync = parseKeySync;
async function serializeKey(key) {
    return key.raw.algorithm
        ? await exportCryptoKey(key.raw)
        : formatKey(key.raw);
}
exports.serializeKey = serializeKey;
/**
 * Generate an AES-GCM 256 bit serialized key.
 */
function generateKey() {
    const keyLength = 32; // bytes
    if (typeof window === 'undefined') {
        // Node.js
        const key = nodeCrypto.randomBytes(keyLength);
        return formatKey(key);
    }
    else {
        // Browser - use WebCrypto
        const key = window.crypto.getRandomValues(new Uint8Array(keyLength));
        return formatKey(key);
    }
}
exports.generateKey = generateKey;
// --
/**
 * Serialize a WebCrypto key into a compact text format.
 *
 * @param key - An exportable WebCrypto key
 */
async function exportCryptoKey(key) {
    const algo = key.algorithm;
    if (algo.name !== 'AES-GCM' || algo.length !== 256) {
        throw new Error('Unsupported key type');
    }
    const raw = await window.crypto.subtle.exportKey('raw', key);
    return formatKey(new Uint8Array(raw));
}
exports.exportCryptoKey = exportCryptoKey;
// -----------------------------------------------------------------------------
/**
 * Internal method: de-serialize a Cloak key into a WebCrypto key.
 * Note that the imported key cannot be re-exported, to limit leakage.
 *
 * @param key - Serialized Cloak key
 * @param usage - What the key is for (encryption or decryption)
 */
async function importKey(key, usage) {
    const match = key.match(exports.cloakKeyRegex);
    if (!match) {
        throw new Error('Unknown key format');
    }
    const raw = codec_1.b64.decode(match.groups.key);
    if (typeof window === 'undefined') {
        // Node.js
        return raw;
    }
    else {
        // Browser
        return await window.crypto.subtle.importKey('raw', raw, {
            name: 'AES-GCM',
            length: 256
        }, true, usage ? [usage] : ['encrypt', 'decrypt']);
    }
}
exports.importKey = importKey;
/**
 * Internal method: de-serialize a Cloak key into an Uint8Array.
 *
 * Available only on Node.js
 *
 * @param key - Serialized Cloak key
 */
function importKeySync(key) {
    const match = key.match(exports.cloakKeyRegex);
    if (!match) {
        throw new Error('Unknown key format');
    }
    return codec_1.b64.decode(match.groups.key);
}
exports.importKeySync = importKeySync;
/**
 * Internal method: calculate a key fingerprint
 * Fingerprint is the first 8 bytes of the SHA-256 of the
 * serialized key text, represented as an hexadecimal string.
 */
async function getKeyFingerprint(key) {
    const data = codec_1.utf8.encode(key);
    if (typeof window === 'undefined') {
        // Node.js
        const hash = nodeCrypto.createHash('sha256');
        hash.update(data);
        return hash.digest('hex').slice(0, exports.FINGERPRINT_LENGTH);
    }
    else {
        // Browser - use WebCrypto
        const hash = await window.crypto.subtle.digest('SHA-256', data);
        return codec_1.hex.encode(new Uint8Array(hash)).slice(0, exports.FINGERPRINT_LENGTH);
    }
}
exports.getKeyFingerprint = getKeyFingerprint;
/**
 * Internal method: calculate a key fingerprint
 * Fingerprint is the first 8 bytes of the SHA-256 of the
 * serialized key text, represented as an hexadecimal string.
 */
function getKeyFingerprintSync(key) {
    const data = codec_1.utf8.encode(key);
    const hash = nodeCrypto.createHash('sha256');
    hash.update(data);
    return hash.digest('hex').slice(0, exports.FINGERPRINT_LENGTH);
}
exports.getKeyFingerprintSync = getKeyFingerprintSync;
