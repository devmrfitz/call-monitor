#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const commander_1 = require("commander");
const dotenv_1 = __importDefault(require("dotenv"));
const fs_1 = __importDefault(require("fs"));
const s_ago_1 = __importDefault(require("s-ago"));
const key_1 = require("./key");
const keychain_1 = require("./keychain");
const message_1 = require("./message");
dotenv_1.default.config();
const program = new commander_1.Command();
const env = {
    keychain: process.env.CLOAK_KEYCHAIN,
    masterKey: process.env.CLOAK_MASTER_KEY
};
const getEnvKeychain = async () => {
    if (!env.keychain || !env.masterKey) {
        return {};
    }
    return await (0, keychain_1.importKeychain)(env.keychain, env.masterKey);
};
const printExports = async (message, keychain, masterKey) => {
    const text = [
        '',
        chalk_1.default.dim(`# ${message}:`),
        `export CLOAK_MASTER_KEY=${masterKey}`,
        `export CLOAK_KEYCHAIN=${await (0, keychain_1.exportKeychain)(keychain, masterKey)}`
    ].join('\n');
    console.log(text);
};
program
    .command('generate')
    .description('Generate an AES-GCM key')
    .action(async () => {
    const key = (0, key_1.generateKey)();
    const fingerprint = await (0, key_1.getKeyFingerprint)(key);
    console.log(chalk_1.default.bold('Key:         '), key);
    console.log(chalk_1.default.bold('Fingerprint: '), fingerprint);
    // todo: print different things based on context:
    // - no master key or keychain:
    //   - the key generated is the master key
    //   - the keychain is empty
    //   - show both exports for master key and keychain
    // - master key and keychain: key rotation scenario
    //   - show exports for new keychain & new key fingerprint
    if (!env.masterKey) {
        // Use the generated key as a master key
        const keychain = await (0, keychain_1.makeKeychain)([]);
        await printExports('Generated new empty keychain', keychain, key);
        return;
    }
    const keychain = await getEnvKeychain();
    keychain[fingerprint] = {
        key: await (0, key_1.parseKey)(key),
        createdAt: Date.now()
    };
    await printExports('Updated keychain', keychain, env.masterKey);
    console.log(`
${chalk_1.default.dim('# To use this new key as default for encryption:')}
export CLOAK_CURRENT_KEY=${fingerprint}`);
});
// --
program
    .command('encrypt [key]')
    .description('Encrypt stdin')
    .option('-l, --line', 'Encrypt line-by-line')
    .action(async (key, { line }) => {
    if (!key) {
        key = process.env.CLOAK_CURRENT_KEY;
    }
    if (key && key.length === key_1.FINGERPRINT_LENGTH) {
        const fingerprint = key;
        const keychain = await getEnvKeychain();
        if (fingerprint in keychain) {
            key = keychain[fingerprint].key;
        }
        else {
            console.error(chalk_1.default.redBright('Error: Missing key (not available in keychain)'));
            process.exit(1);
        }
    }
    if (!key) {
        console.error(chalk_1.default.redBright('Error: Missing key'));
        process.exit(1);
    }
    const stdin = fs_1.default.readFileSync(0, 'utf-8');
    if (!line) {
        const ciphertext = await (0, message_1.encryptString)(stdin, key);
        console.log(ciphertext);
        return;
    }
    for (const line of stdin.split('\n')) {
        const ciphertext = await (0, message_1.encryptString)(line, key);
        console.log(ciphertext);
    }
});
// --
program
    .command('decrypt')
    .description('Decrypt stdin')
    .action(async () => {
    const keychain = await getEnvKeychain();
    if (!keychain) {
        // todo: Provide option to pass a cleartext key for decryption
        console.error(chalk_1.default.redBright('Error: No keychain found and no key provided'));
        process.exit(1);
    }
    const stdin = fs_1.default
        .readFileSync(0, 'utf-8')
        .split('\n')
        .filter(line => line.length > 0);
    for (const message of stdin) {
        try {
            const key = (0, keychain_1.findKeyForMessage)(message, keychain);
            const cleartext = await (0, message_1.decryptString)(message, key);
            console.log(cleartext);
        }
        catch (error) {
            console.error(chalk_1.default.redBright('Error:', error));
        }
    }
});
// --
program
    .command('revoke <keyFingerprint>')
    .description('Remove a key from the environment keychain')
    .action(async (keyFingerprint) => {
    const keychain = await getEnvKeychain();
    if (!(keyFingerprint in keychain)) {
        console.error(chalk_1.default.redBright('Error: No such key in env keychain'));
        process.exit(1);
    }
    if (!env.masterKey) {
        console.error(chalk_1.default.redBright('Error: Master key is missing'));
        process.exit(1);
    }
    const { [keyFingerprint]: _, ...newKeychain } = keychain;
    await printExports('Updated keychain', newKeychain, env.masterKey);
});
// --
program
    .command('keychain [full]')
    .description('List the contents of the environment keychain')
    .option('-f, --full', 'Show the full keys in clear text')
    .action(async (_, { full = false } = {}) => {
    const keychain = await getEnvKeychain();
    const table = await Promise.all(Object.keys(keychain).map(async (fingerprint) => {
        const { key, createdAt } = keychain[fingerprint];
        const creationDate = new Date(createdAt);
        return full
            ? {
                fingerprint,
                createdAt: creationDate.toISOString(),
                key: await (0, key_1.serializeKey)(key)
            }
            : {
                fingerprint,
                created: (0, s_ago_1.default)(creationDate),
                key: '[redacted]'
            };
    }));
    console.table(table);
});
program
    .command('rotate-master-key <key>')
    .description('Generate a new master key & re-encrypt the keychain with it')
    .action(async (key) => {
    const keychain = await getEnvKeychain();
    const newMasterKey = key || (0, key_1.generateKey)();
    await printExports('Updated keychain', keychain, newMasterKey);
});
program.parse(process.argv);
