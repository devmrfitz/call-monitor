"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getKeyAge = exports.findKeyForMessage = exports.exportKeychainSync = exports.exportKeychain = exports.importKeychainSync = exports.importKeychain = exports.makeKeychainSync = exports.makeKeychain = void 0;
const key_1 = require("./key");
const message_1 = require("./message");
/**
 * Create a keychain holding the given list of keys.
 *
 * Runs everywhere (Node.js & browser).
 *
 * @param keys a list of keys to include in the keychain
 */
async function makeKeychain(keys) {
    const keychain = {};
    for (const key of keys) {
        const parsedKey = await (0, key_1.parseKey)(key);
        keychain[parsedKey.fingerprint] = {
            key: parsedKey,
            createdAt: Date.now()
        };
    }
    return keychain;
}
exports.makeKeychain = makeKeychain;
/**
 * Create a keychain holding the given list of keys.
 *
 * Available only for Node.js
 *
 * @param keys a list of keys to include in the keychain
 */
function makeKeychainSync(keys) {
    const keychain = {};
    for (const key of keys) {
        const parsedKey = (0, key_1.parseKeySync)(key);
        keychain[parsedKey.fingerprint] = {
            key: parsedKey,
            createdAt: Date.now()
        };
    }
    return keychain;
}
exports.makeKeychainSync = makeKeychainSync;
/**
 * Decrypt and hydrate the given encrypted keychain.
 *
 * Runs everywhere (Node.js & browser).
 *
 * @param encryptedKeychain - A keychain as exported by exportKeychain
 * @param masterKey - The key used to encrypt the keychain
 */
async function importKeychain(encryptedKeychain, masterKey) {
    const json = await (0, message_1.decryptString)(encryptedKeychain, masterKey);
    const keys = JSON.parse(json);
    const keychain = {};
    for (const { key, ...rest } of keys) {
        const parsedKey = await (0, key_1.parseKey)(key);
        keychain[parsedKey.fingerprint] = {
            key: parsedKey,
            ...rest
        };
    }
    return keychain;
}
exports.importKeychain = importKeychain;
/**
 * Decrypt and hydrate the given encrypted keychain.
 *
 * Available only for Node.js
 *
 * @param encryptedKeychain - A keychain as exported by exportKeychain
 * @param masterKey - The key used to encrypt the keychain
 */
function importKeychainSync(encryptedKeychain, masterKey) {
    const json = (0, message_1.decryptStringSync)(encryptedKeychain, masterKey);
    const keys = JSON.parse(json);
    const keychain = {};
    for (const { key, ...rest } of keys) {
        const parsedKey = (0, key_1.parseKeySync)(key);
        keychain[parsedKey.fingerprint] = {
            key: parsedKey,
            ...rest
        };
    }
    return keychain;
}
exports.importKeychainSync = importKeychainSync;
/**
 * Export a serialized and encrypted version of a keychain.
 *
 * Runs everywhere (Node.js & browser).
 *
 * @param keychain - The keychain to export
 * @param masterKey - The key to use to encrypt the keychain
 * @returns an encrypted keychain string
 */
async function exportKeychain(keychain, masterKey) {
    const rawEntries = Object.values(keychain);
    const entries = [];
    for (const entry of rawEntries) {
        entries.push({
            key: await (0, key_1.serializeKey)(entry.key),
            createdAt: entry.createdAt,
            label: entry.label
        });
    }
    return await (0, message_1.encryptString)(JSON.stringify(entries), masterKey);
}
exports.exportKeychain = exportKeychain;
/**
 * Export a serialized and encrypted version of a keychain
 *
 * Available only for Node.js
 *
 * @param keychain - The keychain to export
 * @param masterKey - The key to use to encrypt the keychain
 * @returns an encrypted keychain string
 */
function exportKeychainSync(keychain, masterKey) {
    const rawEntries = Object.values(keychain);
    const entries = [];
    for (const entry of rawEntries) {
        entries.push({
            key: (0, key_1.formatKey)(entry.key.raw),
            createdAt: entry.createdAt,
            label: entry.label
        });
    }
    return (0, message_1.encryptStringSync)(JSON.stringify(entries), masterKey);
}
exports.exportKeychainSync = exportKeychainSync;
function findKeyForMessage(message, keychain) {
    const fingerprint = (0, message_1.getMessageKeyFingerprint)(message);
    if (!(fingerprint in keychain)) {
        throw new Error('Key is not available');
    }
    return keychain[fingerprint].key;
}
exports.findKeyForMessage = findKeyForMessage;
function getKeyAge(fingerprint, keychain, now = Date.now()) {
    if (!(fingerprint in keychain)) {
        throw new Error('Key is not available');
    }
    return now - keychain[fingerprint].createdAt;
}
exports.getKeyAge = getKeyAge;
