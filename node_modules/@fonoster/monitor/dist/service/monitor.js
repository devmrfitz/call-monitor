"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonitorService = exports.default = void 0;
const monitor_pb_1 = require("./protos/monitor_pb");
const monitor_grpc_pb_1 = require("./protos/monitor_grpc_pb");
Object.defineProperty(exports, "MonitorService", { enumerable: true, get: function () { return monitor_grpc_pb_1.MonitorService; } });
const struct_pb_1 = require("google-protobuf/google/protobuf/struct_pb");
const elasticsearch_1 = require("@elastic/elasticsearch");
const errors_1 = require("@fonoster/errors");
const core_1 = require("@fonoster/core");
const level_1 = require("./level");
const event_type_1 = require("./event_type");
const env_1 = require("../env");
const client = new elasticsearch_1.Client({
    node: `http://${env_1.LOGS_AGGREGRATOR_HOST}:${env_1.LOGS_AGGREGRATOR_PORT}`
});
// eslint-disable-next-line require-jsdoc
class MonitorServer {
    // eslint-disable-next-line require-jsdoc
    async searchEvents(call) {
        const accessKeyId = (0, core_1.getAccessKeyId)(call);
        // TODO:
        // Assert toJavaScript is valid
        const { body } = await client.search({
            body: {
                query: call.request.getQuery().toJavaScript()
            }
        }, {
            asStream: true
        });
        body.setEncoding("utf8");
        const entries = (chunk) => JSON.parse(chunk)
            .hits?.hits?.filter((hit) => hit["_source"]?.accessKeyId === accessKeyId)
            .map((hit) => {
            const entry = new monitor_pb_1.Event();
            entry.setRef(hit["_id"]);
            entry.setMessage(hit["_source"].message);
            entry.setTimestamp(hit["_source"]["@timestamp"]);
            entry.setBody(struct_pb_1.Struct.fromJavaScript(hit["_source"]?.body));
            entry.setEventType(event_type_1.EventType.fromString(hit["_source"]?.eventType));
            entry.setLevel(level_1.Level.fromString(hit["_source"]?.level));
            return entry;
        });
        let payload = "";
        body.on("data", async (chunk) => (payload += chunk));
        body.on("error", (e) => new errors_1.FonosterError(e.message, errors_1.ErrorCodes.UNKNOWN));
        body.on("end", () => {
            entries(payload)?.forEach((e) => call.write(e));
            call.end();
        });
    }
}
exports.default = MonitorServer;
