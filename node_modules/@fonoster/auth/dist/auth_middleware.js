"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (C) 2023 by Fonoster Inc (https://fonoster.com)
 * http://github.com/fonoster/fonoster
 *
 * This file is part of Fonoster
 *
 * Licensed under the MIT License (the "License");
 * you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    https://opensource.org/licenses/MIT
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const grpc_js_1 = require("@grpc/grpc-js");
const logger_1 = require("@fonoster/logger");
const auth_utils_1 = __importDefault(require("./utils/auth_utils"));
const jwt_1 = __importDefault(require("./utils/jwt"));
const role_has_access_1 = __importDefault(require("./utils/role_has_access"));
const logger = (0, logger_1.getLogger)({ service: "auth", filePath: __filename });
class AuthMiddleware {
    privateKey;
    whitelist;
    constructor(privateKey, whitelist = []) {
        this.privateKey = privateKey;
        this.whitelist = whitelist;
    }
    middleware = async (ctx, next, errorCb) => {
        const pathRequest = ctx.service.path;
        logger.verbose(`receiving request [request.path = ${pathRequest}]`);
        if (this.whitelist.includes(pathRequest)) {
            next();
            return;
        }
        const jwtHandler = new auth_utils_1.default(new jwt_1.default());
        const metadata = ctx.call.metadata;
        const accessKeyId = metadata.get("access_key_id")[0];
        const accessKeySecret = metadata.get("access_key_secret")[0]?.toString();
        try {
            if (!accessKeyId || !accessKeySecret) {
                errorCb({
                    code: grpc_js_1.status.UNAUTHENTICATED,
                    message: "UNAUTHENTICATED"
                });
                return;
            }
            const result = await jwtHandler.validateToken({ accessToken: accessKeySecret }, this.privateKey);
            if (result.isValid) {
                if (result.data.accessKeyId != accessKeyId)
                    errorCb({
                        code: grpc_js_1.status.UNAUTHENTICATED,
                        // TODO: Improve error message
                        message: "invalid authentication"
                    });
                const hasAccess = await (0, role_has_access_1.default)(result.data.role, pathRequest);
                if (hasAccess) {
                    await next();
                }
                else {
                    errorCb({
                        code: grpc_js_1.status.PERMISSION_DENIED,
                        // TODO: Improve error message
                        message: "permission denied"
                    });
                }
            }
            else {
                errorCb({
                    code: grpc_js_1.status.UNAUTHENTICATED,
                    // TODO: Improve error message
                    message: "invalid authentication"
                });
            }
        }
        catch (e) {
            errorCb({
                code: grpc_js_1.status.INTERNAL,
                message: e
            });
        }
    };
}
exports.default = AuthMiddleware;
