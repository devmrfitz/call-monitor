"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthService = exports.default = void 0;
const fs_1 = __importDefault(require("fs"));
const auth_pb_1 = require("./protos/auth_pb");
const auth_grpc_pb_1 = require("./protos/auth_grpc_pb");
Object.defineProperty(exports, "AuthService", { enumerable: true, get: function () { return auth_grpc_pb_1.AuthService; } });
const errors_1 = require("@fonoster/errors");
const logger_1 = require("@fonoster/logger");
const envs_1 = require("../envs");
const auth_utils_1 = __importDefault(require("../utils/auth_utils"));
const jwt_1 = __importDefault(require("../utils/jwt"));
const logger = (0, logger_1.getLogger)({ service: "auth", filePath: __filename });
const authenticator = new auth_utils_1.default(new jwt_1.default());
const rbac = JSON.parse(fs_1.default.readFileSync(envs_1.APISERVER_RBAC_CONFIG, "utf8"));
class AuthServer {
    async validateToken(call, callback) {
        const result = await authenticator.validateToken({ accessToken: call.request.getToken() }, envs_1.APISERVER_JWT_PRIVATE_KEY);
        const validateTokenResponse = new auth_pb_1.ValidateTokenResponse();
        validateTokenResponse.setValid(result.isValid);
        callback(null, validateTokenResponse);
    }
    async createToken(call, callback) {
        // TODO: We need to validate the token and verify
        // it has permissions to create token since the auth module
        // doesnt pass thru the auth middleware.
        logger.verbose("creating token", {
            accessKeyId: call.request.getAccessKeyId()
        });
        const result = await authenticator.createToken(call.request.getAccessKeyId(), envs_1.APISERVER_JWT_AUTH_ISS, call.request.getRoleName(), envs_1.APISERVER_JWT_PRIVATE_KEY, call.request.getExpiration() || "30d");
        const response = new auth_pb_1.CreateTokenResponse();
        response.setToken(result.accessToken);
        callback(null, response);
    }
    async createNoAccessToken(call, callback) {
        // TODO: We need to validate the token and verify
        // it has permissions to create token since the auth module
        // doesnt pass thru the auth middleware.
        logger.verbose("creating no access token", {
            accessKeyId: call.request.getAccessKeyId()
        });
        const result = await authenticator.createToken(call.request.getAccessKeyId(), envs_1.APISERVER_JWT_AUTH_ISS, "NO_ACCESS", envs_1.APISERVER_JWT_PRIVATE_KEY, "1d");
        const response = new auth_pb_1.CreateTokenResponse();
        response.setToken(result.accessToken);
        callback(null, response);
    }
    async getRole(call, callback) {
        try {
            const rawRole = rbac.filter((r) => r.name === call.request.getName())[0];
            if (rawRole) {
                const role = new auth_pb_1.Role();
                role.setAccessList(rawRole.access);
                role.setName(rawRole.name);
                role.setDescription(rawRole.description);
                callback(null, role);
                return;
            }
            callback(new errors_1.FonosterError("Role not found", errors_1.ErrorCodes.NOT_FOUND), null);
        }
        catch (e) {
            callback(new errors_1.FonosterError(e, errors_1.ErrorCodes.UNKNOWN), null);
        }
    }
}
exports.default = AuthServer;
