"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommonPB = exports.AppsPB = void 0;
/*
 * Copyright (C) 2023 by Fonoster Inc (https://fonoster.com)
 * http://github.com/fonoster/fonoster
 *
 * This file is part of Fonoster
 *
 * Licensed under the MIT License (the "License");
 * you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    https://opensource.org/licenses/MIT
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const common_1 = require("@fonoster/common");
const grpc_promise_1 = require("grpc-promise");
const apps_grpc_pb_1 = require("../service/protos/apps_grpc_pb");
const struct_pb_1 = require("google-protobuf/google/protobuf/struct_pb");
const apps_pb_1 = __importDefault(require("../service/protos/apps_pb"));
exports.AppsPB = apps_pb_1.default;
const common_pb_1 = __importDefault(require("../service/protos/common_pb"));
exports.CommonPB = common_pb_1.default;
/**
 * @classdesc Use Fonoster Apps, a capability of Fonoster Voice Subsystem,
 * to create, update, get and delete Voice Applications. Apps requires of a
 * running Fonoster deployment.
 *
 * @extends APIClient
 * @example
 *
 * const Fonoster = require("@fonoster/sdk")
 * const apps = new Fonoster.Apps()
 *
 * const request = {
 *   name: "My application",
 *   initialDtmf: "1234",
 *   speechConfig: {
 *     secretName: "my-secret",
 *     voice: "en-US-Wavenet-F"
 *   },
 *   intentsEngineConfig: {
 *     secretName: "my-secret",
 *     projectId: "my-project"
 *   }
 * }
 *
 * apps.createApp(request)
 * .then(result => {
 *   console.log(result)             // successful response
 * }).catch(e => console.error(e))   // an error occurred
 */
class Apps extends common_1.APIClient {
    /**
     * Constructs a new Apps object.
     *
     * @param {ClientOptions} options - Options to indicate the objects endpoint
     * @see module:core:APIClient
     */
    constructor(options) {
        super(apps_grpc_pb_1.AppsClient, options);
        super.init();
        (0, grpc_promise_1.promisifyAll)(super.getService(), { metadata: super.getMeta() });
    }
    /**
     * Creates a new Agent on the SIP Proxy subsystem.
     *
     * @param {CreateAppRequest} request -  Request to create a new Voice Application
     * @param {string} request.name - The name of the application
     * @param {string} request.initialDtmf - Optional DTMF code to be sent at after answer the call
     * @param {string} request.activationIntentId - Optional intent id to "wake" the application. Similar to "Alexa!"
     * @param {number} request.activationTimeout - Time in seconds for the duration of the `AWAKE_ACTIVE` state,
     * set for the activation command. After this time the bot will return to `AWAKE_PASSIVE` and new intents will be ignored. Defaults to 15000
     * @param {number} request.interactionTimeout - Timeout, in seconds, to ask again for user input. Use -1 for no timeout. Defaults to -1
     * @param {boolean} request.enableEvents - If set to true it will send events to WS clients subscribed to events. Defaults to false
     * @param {TransferConfig} request.transferConfig - Transfer configuration object
     * @param {string} request.transferConfig.message - Optional message to play while transfering
     * @param {string} request.transferConfig.messageBusy - Optional message to play if callee is busy
     * @param {string} request.transferConfig.messageBusy - Optional message to play if callee does not answer
     * @param {SpeechConfig} request.speechConfig - Speech configuration. Value varies based on implementation
     * @param {IntentsEngineConfig} request.intentsEngineConfig - Intents Engine. Value varies based on implementation
     * @return {Promise<CreateAppResponse>}
     * @see GoogleSpeechConfig
     * @see DialogflowES
     * @see DialogflowCX
     * @example
     *
     * const request = {
     *   name: "My application",
     *   initialDtmf: "1234",
     *   speechConfig: {
     *     secretName: "my-secret",
     *     voice: "en-US-Wavenet-F"
     *   },
     *   intentsEngineConfig: {
     *     secretName: "my-secret",
     *     projectId: "my-project"
     *   }
     * }
     *
     * apps.createApp(request)
     * .then(result => {
     *   console.log(result)            // returns the CreateAppResponse interface
     * }).catch(e => console.error(e))  // an error occurred
     */
    async createApp(request) {
        const transferConfig = new apps_pb_1.default.TransferConfig();
        transferConfig.setMessage(request?.transferConfig?.message);
        transferConfig.setMessageBusy(request?.transferConfig?.messageBusy);
        transferConfig.setMessageNoAnswer(request?.transferConfig?.messageNoAnswer);
        const outRequest = new apps_pb_1.default.CreateAppRequest();
        outRequest.setName(request.name);
        outRequest.setInitialDtmf(request.initialDtmf);
        outRequest.setActivationIntentId(request.activationIntentId);
        outRequest.setActivationTimeout(request.activationTimeout);
        outRequest.setInteractionTimeout(request.interactionTimeout);
        outRequest.setEnableEvents(request.enableEvents);
        outRequest.setTransferConfig(transferConfig);
        outRequest.setIntentsEngineConfig(struct_pb_1.Struct.fromJavaScript(request.intentsEngineConfig));
        outRequest.setSpeechConfig(struct_pb_1.Struct.fromJavaScript(request.speechConfig));
        const res = await super.getService().createApp().sendMessage(outRequest);
        return {
            ref: res.getRef(),
            name: res.getName(),
            initialDtmf: res.getInitialDtmf(),
            activationIntentId: res.getActivationIntentId(),
            activationTimeout: res.getActivationTimeout(),
            interactionTimeout: res.getInteractionTimeout(),
            enableEvents: res.getEnableEvents(),
            transferConfig: {
                message: res?.getTransferConfig()?.getMessage(),
                messageBusy: res?.getTransferConfig()?.getMessageBusy(),
                messageNoAnswer: res?.getTransferConfig()?.getMessageNoAnswer()
            },
            speechConfig: res.getSpeechConfig().toJavaScript(),
            intentsEngineConfig: res.getIntentsEngineConfig().toJavaScript(),
            createTime: res.getCreateTime(),
            updateTime: res.getUpdateTime()
        };
    }
    /**
     * Retrives a Voice Application by reference.
     *
     * @param {string} ref - Reference to Application
     * @return {Promise<GetAppResponse>} The Application
     * @throws if ref is null or App does not exist
     * @example
     *
     * const ref = "aynB1z0tzd";
     *
     * apps.getApp(ref)
     * .then(result => {
     *   console.log(result)             // returns the GetAppResponse interface
     * }).catch(e => console.error(e))   // an error occurred
     */
    async getApp(ref) {
        const request = new apps_pb_1.default.GetAppRequest();
        request.setRef(ref);
        const res = await super.getService().getApp().sendMessage(request);
        return {
            ref: res.getRef(),
            name: res.getName(),
            initialDtmf: res.getInitialDtmf(),
            activationIntentId: res.getActivationIntentId(),
            activationTimeout: res.getActivationTimeout(),
            interactionTimeout: res.getInteractionTimeout(),
            enableEvents: res.getEnableEvents(),
            transferConfig: {
                message: res?.getTransferConfig()?.getMessage(),
                messageBusy: res?.getTransferConfig()?.getMessageBusy(),
                messageNoAnswer: res?.getTransferConfig()?.getMessageNoAnswer()
            },
            speechConfig: res.getSpeechConfig().toJavaScript(),
            intentsEngineConfig: res.getIntentsEngineConfig().toJavaScript(),
            createTime: res.getCreateTime(),
            updateTime: res.getUpdateTime()
        };
    }
    /**
     * Update a Voice Application.
     *
     * @param {UpdateAppRequest} request -  Request to update an existing Voice Application
     * @param {string} request.ref - The reference of the application
     * @param {string} request.name - The name of the application
     * @param {string} request.initialDtmf - Optional DTMF code to be sent at after answer the call
     * @param {string} request.activationIntentId - Optional intent id to "wake" the application. Similar to "Alexa!"
     * @param {number} request.activationTimeout - Time in seconds for the duration of the `AWAKE_ACTIVE` state,
     * set for the activation command. After this time the bot will return to `AWAKE_PASSIVE` and new intents will be ignored. Defaults to 15000
     * @param {number} request.interactionTimeout - Timeout, in seconds, to ask again for user input. Use -1 for no timeout. Defaults to -1
     * @param {boolean} request.enableEvents - If set to true it will send events to WS clients subscribed to events. Defaults to false
     * @param {TransferConfig} request.transferConfig - Transfer configuration object
     * @param {string} request.transferConfig.message - Optional message to play while transfering
     * @param {string} request.transferConfig.messageBusy - Optional message to play if callee is busy
     * @param {string} request.transferConfig.messageBusy - Optional message to play if callee does not answer
     * @param {SpeechConfig} request.speechConfig - Speech configuration. Value varies based on implementation
     * @param {IntentsEngineConfig} request.intentsEngineConfig - Intents Engine configuration. Value varies based on implementation
     * @return {Promise<CreateAppResponse>}
     * @see GoogleSpeechConfig
     * @see DialogflowES
     * @see DialogflowCX
     * @example
     *
     * const request = {
     *   ref: "aynB1z0tzd",
     *   name: "My new application name",
     *   speechConfig: {
     *     secretName: "my-secret",
     *     voice: "en-US-Wavenet-F"
     *   },
     *   intentsEngineConfig: {
     *     secretName: "my-secret"
     *   }
     * }
     *
     * apps.updateApp(request)
     * .then(result => {
     *   console.log(result)            // returns the CreateAppResponse interface
     * }).catch(e => console.error(e))  // an error occurred
     */
    async updateApp(request) {
        const transferConfig = new apps_pb_1.default.TransferConfig();
        transferConfig.setMessage(request?.transferConfig?.message);
        transferConfig.setMessageBusy(request?.transferConfig?.messageBusy);
        transferConfig.setMessageNoAnswer(request?.transferConfig?.messageNoAnswer);
        const outRequest = new apps_pb_1.default.UpdateAppRequest();
        outRequest.setRef(request.ref);
        Object.keys(request)
            .filter((key) => !["speechConfig", "intentsEngineConfig", "transferConfig"].includes(key))
            .forEach((key) => {
            if (request[key]) {
                const capitalKey = key.charAt(0).toUpperCase() + key.slice(1);
                outRequest[`set${capitalKey}`](request[key]);
            }
        });
        if (transferConfig.getMessage() ||
            transferConfig.getMediaBusy() ||
            transferConfig.getMediaNoAnswer())
            outRequest.setTransferConfig(transferConfig);
        if (request.intentsEngineConfig)
            outRequest.setIntentsEngineConfig(struct_pb_1.Struct.fromJavaScript(request.intentsEngineConfig));
        if (request.speechConfig)
            outRequest.setSpeechConfig(struct_pb_1.Struct.fromJavaScript(request.speechConfig));
        const res = await super.getService().updateApp().sendMessage(outRequest);
        return {
            ref: res.getRef()
        };
    }
    /**
     * List of Voice Applications in your Project.
     *
     * @param {ListAgentsRequest} request - Optional parameter with size and
     * token for the request
     * @param {number} request.pageSize - Elements per page
     * (defaults to 20)
     * @param {string} request.pageToken - The next_page_token value returned from
     * a previous List request, if any
     * @return {Promise<ListAppsResponse>} Paginated List of Applications
     * @example
     *
     * const request = {
     *    pageSize: 20,
     *    pageToken: 2
     * }
     *
     * apps.listApps(request)
     * .then(() => {
     *   console.log(result)            // returns a ListAppsResponse interface
     * }).catch(e => console.error(e))  // an error occurred
     */
    async listApps(request) {
        const r = new apps_pb_1.default.ListAppsRequest();
        r.setPageSize(request.pageSize);
        r.setPageToken(request.pageToken);
        r.setView(request.view);
        const paginatedList = await super.getService().listApps().sendMessage(r);
        return {
            nextPageToken: paginatedList.getNextPageToken(),
            apps: paginatedList.getAppsList().map((a) => {
                return {
                    ref: a.getRef(),
                    name: a.getName(),
                    initialDtmf: a.getInitialDtmf(),
                    activationIntentId: a.getActivationIntentId(),
                    activationTimeout: a.getActivationTimeout(),
                    interactionTimeout: a.getInteractionTimeout(),
                    enableEvents: a.getEnableEvents(),
                    transferConfig: {
                        message: a?.getTransferConfig()?.getMessage(),
                        messageBusy: a?.getTransferConfig()?.getMessageBusy(),
                        messageNoAnswer: a?.getTransferConfig()?.getMessageNoAnswer()
                    },
                    speechConfig: a.getSpeechConfig().toJavaScript(),
                    intentsEngineConfig: a.getIntentsEngineConfig().toJavaScript(),
                    createTime: a.getCreateTime(),
                    updateTime: a.getUpdateTime()
                };
            })
        };
    }
    /**
     * Deletes a Voice Application in your Project.
     *
     * @param {string} ref - Apps's reference
     * @example
     *
     * const ref = "aynB1z0tzd"
     *
     * apps.deleteApp(ref)
     * .then(() => {
     *   console.log("done")            // returns a reference of the Application
     * }).catch(e => console.error(e))  // an error occurred
     */
    async deleteApp(ref) {
        const req = new apps_pb_1.default.DeleteAppRequest();
        req.setRef(ref);
        await super.getService().deleteApp().sendMessage(req);
        return { ref };
    }
}
exports.default = Apps;
// WARNING: Workaround for support to commonjs clients
module.exports = Apps;
module.exports.AppsPB = apps_pb_1.default;
module.exports.CommonPB = common_pb_1.default;
