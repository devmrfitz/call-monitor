"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppsService = void 0;
const core_1 = require("@fonoster/core");
const apps_1 = require("../client/apps");
const apps_grpc_pb_1 = require("./protos/apps_grpc_pb");
Object.defineProperty(exports, "AppsService", { enumerable: true, get: function () { return apps_grpc_pb_1.AppsService; } });
const apps_pb_1 = require("./protos/apps_pb");
const common_pb_1 = require("./protos/common_pb");
const errors_1 = require("@fonoster/errors");
const nanoid_1 = require("nanoid");
const decoder_1 = __importDefault(require("./decoder"));
const encoder_1 = __importDefault(require("./encoder"));
class AppsServer {
    async createApp(call, callback) {
        try {
            // TODO: Needs assertions
            const redis = (0, core_1.getRedisConnection)();
            const ref = (0, nanoid_1.nanoid)(10);
            const app = new apps_1.AppsPB.App();
            app.setRef(ref);
            app.setAccessKeyId((0, core_1.getAccessKeyId)(call));
            app.setInitialDtmf(call.request.getInitialDtmf());
            app.setActivationIntentId(call.request.getActivationIntentId());
            app.setActivationTimeout(call.request.getActivationTimeout());
            app.setInteractionTimeout(call.request.getInteractionTimeout());
            app.setEnableEvents(call.request.getEnableEvents());
            app.setTransferConfig(call.request.getTransferConfig());
            app.setSpeechConfig(call.request.getSpeechConfig());
            app.setIntentsEngineConfig(call.request.getIntentsEngineConfig());
            app.setName(call.request.getName());
            app.setUpdateTime(new Date().toISOString());
            app.setCreateTime(new Date().toISOString());
            redis.set(ref, (0, encoder_1.default)(app));
            redis.sadd("apps_" + app.getAccessKeyId(), ref);
            callback(null, app);
        }
        catch (e) {
            callback(e, null);
        }
    }
    async updateApp(call, callback) {
        try {
            // TODO: Needs assertions
            const redis = (0, core_1.getRedisConnection)();
            const ref = call.request.getRef();
            const raw = await redis.get(ref);
            if (!raw)
                throw new errors_1.FonosterError("not found", errors_1.ErrorCodes.NOT_FOUND);
            const app = (0, decoder_1.default)(raw.toString());
            if ((0, core_1.getAccessKeyId)(call) !== app.getAccessKeyId()) {
                throw new errors_1.FonosterError("permission denied", errors_1.ErrorCodes.PERMISSION_DENIED);
            }
            if (call.request.getInitialDtmf() !== undefined)
                app.setInitialDtmf(call.request.getInitialDtmf());
            if (call.request.getActivationIntentId() !== undefined)
                app.setActivationIntentId(call.request.getActivationIntentId());
            if (call.request.getActivationTimeout() !== undefined)
                app.setActivationTimeout(call.request.getActivationTimeout());
            if (call.request.getInteractionTimeout() !== undefined)
                app.setInteractionTimeout(call.request.getInteractionTimeout());
            if (call.request.getEnableEvents() !== undefined)
                app.setEnableEvents(call.request.getEnableEvents());
            if (call.request.getName() !== undefined)
                app.setName(call.request.getName());
            if (call.request.getIntentsEngineConfig())
                app.setIntentsEngineConfig(call.request.getIntentsEngineConfig());
            if (call.request.getSpeechConfig())
                app.setSpeechConfig(call.request.getSpeechConfig());
            if (call.request.getTransferConfig()?.getMessage() !== undefined ||
                call.request.getTransferConfig()?.getMediaBusy() !== undefined ||
                call.request.getTransferConfig()?.getMediaNoAnswer() !== undefined)
                app.setTransferConfig(call.request.getTransferConfig());
            app.setUpdateTime(new Date().toISOString());
            redis.set(ref, (0, encoder_1.default)(app));
            callback(null, app);
        }
        catch (e) {
            callback(e, null);
        }
    }
    async listApps(call, callback) {
        try {
            const redis = (0, core_1.getRedisConnection)();
            const list = await redis.smembers("apps_" + (0, core_1.getAccessKeyId)(call));
            const Apps = await Promise.all(list.map(async (ref) => {
                const raw = (await redis.get(ref)).toString();
                return (0, decoder_1.default)(raw);
            }));
            const response = new apps_pb_1.ListAppsResponse();
            // TODO: Implement pagination
            response.setNextPageToken("1");
            response.setAppsList(Apps);
            callback(null, response);
        }
        catch (e) {
            callback(e, null);
        }
    }
    async getApp(call, callback) {
        try {
            const redis = (0, core_1.getRedisConnection)();
            const ref = call.request.getRef();
            const raw = await redis.get(ref);
            if (!raw)
                throw new errors_1.FonosterError("not found", errors_1.ErrorCodes.NOT_FOUND);
            const app = (0, decoder_1.default)(raw.toString());
            if ((0, core_1.getAccessKeyId)(call) !== app.getAccessKeyId()) {
                throw new errors_1.FonosterError("permission denied", errors_1.ErrorCodes.PERMISSION_DENIED);
            }
            callback(null, app);
        }
        catch (e) {
            callback(e, null);
        }
    }
    async deleteApp(call, callback) {
        try {
            const redis = (0, core_1.getRedisConnection)();
            const ref = call.request.getRef();
            const raw = await redis.get(ref);
            if (!raw)
                throw new errors_1.FonosterError("not found", errors_1.ErrorCodes.NOT_FOUND);
            const app = (0, decoder_1.default)(raw.toString());
            if ((0, core_1.getAccessKeyId)(call) !== app.getAccessKeyId()) {
                throw new errors_1.FonosterError("permission denied", errors_1.ErrorCodes.PERMISSION_DENIED);
            }
            redis.del(app.getRef());
            redis.srem("apps_" + app.getAccessKeyId(), app.getRef());
            callback(null, new common_pb_1.Empty());
        }
        catch (e) {
            callback(e, null);
        }
    }
}
exports.default = AppsServer;
