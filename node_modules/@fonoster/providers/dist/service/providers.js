"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProvidersService = exports.default = void 0;
const providers_pb_1 = require("./protos/providers_pb");
const common_pb_1 = require("./protos/common_pb");
const providers_grpc_pb_1 = require("./protos/providers_grpc_pb");
Object.defineProperty(exports, "ProvidersService", { enumerable: true, get: function () { return providers_grpc_pb_1.ProvidersService; } });
const core_1 = require("@fonoster/core");
const core_2 = require("@fonoster/core");
const decoder_1 = __importDefault(require("./decoder"));
const assertions_1 = require("./assertions");
class ProvidersServer {
    async listProviders(call, callback) {
        const result = await core_2.ResourceServer.listResources(core_1.Kind.GATEWAY, call);
        const response = new providers_pb_1.ListProvidersResponse();
        if (result && result.resources) {
            const providers = result.resources.map((resource) => (0, decoder_1.default)(resource));
            response.setNextPageToken(result.nextPageToken + "");
            response.setProvidersList(providers);
        }
        callback(null, response);
    }
    async createProvider(call, callback) {
        try {
            // The host must be hostname:{port}
            (0, assertions_1.assertIsValidHost)(call.request.getHost());
            const resource = new core_1.ResourceBuilder(core_1.Kind.GATEWAY, call.request.getName())
                .withCredentials(call.request.getUsername(), call.request.getSecret())
                .withHost(call.request.getHost())
                .withTransport(call.request.getTransport())
                .withExpires(call.request.getExpires())
                .withMetadata({ accessKeyId: (0, core_2.getAccessKeyId)(call) })
                .withSendRegister(call.request.getRegister())
                .build();
            const result = await (0, core_2.createResource)(resource);
            callback(null, (0, decoder_1.default)(result));
        }
        catch (e) {
            callback(e, null);
        }
    }
    async updateProvider(call, callback) {
        try {
            (0, assertions_1.assertIsValidHost)(call.request.getHost());
            const provider = (await core_2.ResourceServer.getResource(core_1.Kind.GATEWAY, call));
            const resource = new core_1.ResourceBuilder(core_1.Kind.GATEWAY, call.request.getName(), provider.metadata.ref)
                .withMetadata({
                createdOn: provider.metadata.createdOn
            })
                .withCredentials(call.request.getUsername(), call.request.getSecret())
                .withHost(call.request.getHost())
                .withTransport(call.request.getTransport())
                .withExpires(call.request.getExpires())
                .withSendRegister(call.request.getRegister())
                .build();
            const result = await (0, core_2.updateResource)({
                resource,
                accessKeyId: (0, core_2.getAccessKeyId)(call)
            });
            callback(null, (0, decoder_1.default)(result));
        }
        catch (e) {
            callback(e, null);
        }
    }
    async getProvider(call, callback) {
        try {
            const result = await core_2.ResourceServer.getResource(core_1.Kind.GATEWAY, call);
            callback(null, (0, decoder_1.default)(result));
        }
        catch (e) {
            callback(e, null);
        }
    }
    async deleteProvider(call, callback) {
        try {
            await core_2.ResourceServer.deleteResource(core_1.Kind.GATEWAY, call);
            callback(null, new common_pb_1.Empty());
        }
        catch (e) {
            callback(e, null);
        }
    }
}
exports.default = ProvidersServer;
