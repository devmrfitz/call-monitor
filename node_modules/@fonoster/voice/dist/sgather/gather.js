"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const verb_1 = require("../verb");
const pubsub_js_1 = __importDefault(require("pubsub-js"));
const logger_1 = __importDefault(require("@fonoster/logger"));
const deepmerge_1 = __importDefault(require("deepmerge"));
const stream_data_1 = __importDefault(require("./stream_data"));
const source_speech_1 = __importDefault(require("./source_speech"));
const defaultOptions = {
    source: "speech,dtmf"
};
class SGatherVerb extends verb_1.Verb {
    constructor(request, speechProvider) {
        super(request);
        this.speechProvider = speechProvider;
        // Assert speech provider is available if source includes speech
    }
    async run(opts) {
        const options = (0, deepmerge_1.default)(defaultOptions, opts);
        const streamData = new stream_data_1.default();
        logger_1.default.verbose(`@fonoster/voice started sgather [source = ${options.source}]`);
        if (options.source.includes("dtmf")) {
            const token = pubsub_js_1.default.subscribe(`DtmfReceived.${this.request.sessionId}`, (type, data) => {
                const key = data.data;
                streamData.emit("dtmf", key);
            });
            streamData.setDtmfSubscribeToken(token);
        }
        if (options.source.includes("speech")) {
            const { speechStream, token } = await (0, source_speech_1.default)(this.request.sessionId, opts, super.getSelf(), this.speechProvider);
            streamData.setSpeechSubscribeToken(token);
            speechStream.on("transcript", (data) => streamData.emit("transcript", data));
        }
        return streamData;
    }
}
exports.default = SGatherVerb;
