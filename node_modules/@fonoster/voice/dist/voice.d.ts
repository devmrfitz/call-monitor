import { GatherOptions } from "./gather/gather";
import { MuteOptions } from "./mute/mute";
import { PlayOptions } from "./play/play";
import { RecordOptions, RecordResult } from "./record/record";
import { PlaybackControl } from "./playback/playback";
import { SayOptions } from "./say/types";
import { VoiceRequest } from "./types";
import { Plugin } from "@fonoster/common";
import { SGatherOptions } from "./sgather/gather";
import { SGatherStream } from "./sgather/types";
import { DtmfOptions } from "./dtmf/types";
import { DialOptions } from "./dial/types";
import StreamStatus from "./dial/status_stream";
import { VoiceTracer } from "./tracer";
/**
 * @classdesc Use the VoiceResponse object, to construct advance Interactive
 * Voice Response (IVR) applications.
 *
 * @extends Verb
 * @example
 *
 * import { VoiceServer } from "@fonoster/voice";
 *
 * async function handler (request, response) {
 *   await response.answer();
 *   await response.play("sound:hello-world");
 * }
 *
 * const voiceServer = new VoiceServer({base: '/voiceapp'})
 * voiceServer.listen(handler, { port: 3000 })
 */
export default class VoiceResponse {
    request: VoiceRequest;
    plugins: {};
    voiceTracer: VoiceTracer;
    /**
     * Constructs a new VoiceResponse object.
     *
     * @param {VoiceRequest} request - Options to indicate the objects endpoint
     * @see module:core:APIClient
     */
    constructor(request: VoiceRequest, voiceTracer: VoiceTracer);
    /**
     * Adds a tts or asr plugin. Only one type of plugin can be attached.
     *
     * @param plugin
     * @see GoogleTTS
     * @see GoogleASR
     */
    use(plugin: Plugin): void;
    /**
     * Play an audio in the channel.
     *
     * @param {string} media - Sound name or uri with audio file
     * @param {PlayOptions} options - Optional parameters to alter the command's normal
     * behavior
     * @param {string} options.offset - Milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified
     * @param {string} options.skip - Milliseconds to skip for forward/reverse operations
     * @param {string} options.playbackId - Playback identifier to use in Playback operations
     * @see Playback
     * @example
     *
     * async function handler (request, response) {
     *   await response.answer();
     *   await response.play("https://soundsserver:9000/sounds/hello-world.wav");
     * }
     */
    play(media: string, options?: PlayOptions): Promise<void>;
    /**
     * Converts a text into a sound and sends sound to media server. To use this verb, you must
     * first setup a TTS plugin such as MaryTTS, GoogleTTS, or AWS PollyTTS
     *
     * @param {string} text - Converts a text into a sound and sends sound to media server
     * @param {SayOptions} options - Optional parameters to alter the command's normal
     * behavior
     * @param {string} options.offset - Milliseconds to skip before playing
     * @param {string} options.skip - Milliseconds to skip for forward/reverse operations
     * @param {string} options.playbackId - Playback identifier to use in Playback operations
     * @see Play
     * @see Voice.use
     * @example
     *
     * async function handler (request, response) {
     *   await response.answer();
     *   response.use(new GoogleTTS())
     *   await response.say("Hello workd");   // Plays the sound using GoogleTTS's default values
     * }
     */
    say(text: string, options?: SayOptions): Promise<void>;
    /**
     * Waits for data entry from the user's keypad or from a speech provider.
     *
     * @param {GatherOptions} options - Options to select the maximum number of digits, final character, and timeout
     * @param {number} options.numDigits - Milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified
     * @param {number} options.timeout - Milliseconds to wait before timeout. Defaults to 4000. Use zero for no timeout.
     * @param {string} options.finishOnKey - Optional last character to wait for. Defaults to '#'. It will not be included in the returned digits
     * @param {string} options.source - Where to listen as input source. This option accepts `dtmf` and `speech`. A speech provider must be configure
     * when including the `speech` source. You might inclue both with `dtmf,speech`. Defaults to `dtmf`
     * @note When including `speech` the default timeout is 10000 (10s).
     * @see SpeechProvider
     * @example
     *
     * async function handler (request, response) {
     *   await response.answer();
     *   const digits = await response.gather({source: "dtmf,speech", numDigits: 3});
     *   console.log("digits: " + digits);
     * }
     */
    gather(options?: GatherOptions): Promise<string>;
    /**
     * Waits for data entry from the user's keypad or from a stream speech provider. This command is different from `gather`
     * in that it returns a stream of results instead of a single result. You can think of it as active listening.
     *
     * @param {SGatherOptions} options - Options object for the SGather verb
     * @param {string} options.source - Where to listen as input source. This option accepts `dtmf` and `speech`. A speech provider must be configure
     * when including the `speech` source. You might inclue both with `dtmf,speech`. Defaults to `speech,dtmf`
     * @return {SGatherStream} The SGatherStream fires events via the `on` method for `transcription`, `dtmf`, and `error`. And the stream can be close
     * with the `close` function.
     * @see StreamSpeechProvider
     * @example
     *
     * async function handler (request, response) {
     *   await response.answer();
     *   const stream = await response.sgather({source: "dtmf,speech"});
     *
     *   stream.on("transcript", (text, isFinal) => {
     *      console.log("transcript: %s", text);
     *   })
     *
     *   stream.on("dtmf", digit => {
     *      console.log("digit: " + digit);
     *      if (digit === "#") stream.close();
     *   })
     * }
     */
    sgather(options?: SGatherOptions): Promise<SGatherStream>;
    /**
     * Sends dtmf tones to the current session.
     *
     * @param {DtmfOptions} options - Options object for the Dtmf verb
     * @param {string} options.dtmf - A string of the dtmf tones
     * @example
     *
     * async function handler (request, response) {
     *    await response.answer();
     *    await response.play("sound:hello-world");
     *    await response.dtmf({dtmf: "1234"});
     * }
     */
    dtmf(options: DtmfOptions): Promise<void>;
    /**
     * Forwards the call to an Agent or the PSTN.
     *
     * @param {string} destination - Number or Agent to forward the call to
     * @param {DialOptions} options - Options object for the Dial verb
     * @param {timeout} options.timeout - Dial timeout
     * @return {StatusStream} The StatusStream fires events via the `on` method for `progress`, `answer`, `noanswer`, and `busy`. And the stream can be close
     * with the `close` function.
     * @example
     *
     * async function handler (request, response) {
     *    await response.answer();
     *    await response.say("dialing number");
     *    const stream = await response.dial("17853178070");
     *    stream.on("progress", console.log)
     *    stream.on("answer", console.log)
     *    stream.on("busy", console.log)
     * }
     */
    dial(destination: string, options?: DialOptions): Promise<StreamStatus>;
    /**
     * Returns a PlaybackControl control object.
     *
     * @param {string} playbackId - Playback identifier to use in Playback operations
     * @see Play
     * @example
     *
     * async function handler (request, response) {
     *   await response.answer();
     *   response.onDtmfReceived(async(digit) => {
     *      const control = response.playback("1234")
     *      digit === "3"
     *        ? await control.restart()
     *        : await control.forward()
     *   })
     *
     *   await response.play("https://soundsserver:9000/sounds/hello-world.wav", {
     *      playbackId: "1234"
     *   });
     * }
     */
    playback(playbackId: string): PlaybackControl;
    /**
     * Listens event publication.
     *
     * @param {Function} handler - Event handler
     * @example
     *
     * async function handler (request, response) {
     *   await response.answer();
     *   response.on("DtmfReceived", async(digit) => {
     *      const control = response.playback("1234")
     *      digit === "3"
     *        ? await control.restart()
     *        : await control.forward()
     *   })
     *
     *   await response.play("https://soundsserver:9000/sounds/hello-world.wav", {
     *      playbackId: "1234"
     *   });
     * }
     */
    on(topic: string, handler: Function): Promise<void>;
    /**
     * Mutes a channel.
     *
     * @param {MuteOptions} options - Indicate which direction of he communication to mute
     * @param {string} options.direction - Possible values are 'in', 'out', and 'both'
     * @see unmute
     * @example
     *
     * async function handler (request, response) {
     *   await response.answer();
     *   await response.mute();       // Will mute both directions
     * }
     */
    mute(options?: MuteOptions): Promise<void>;
    /**
     * Unmutes a channel.
     *
     * @param {MuteOptions} options - Indicate which direction of he communication to unmute
     * @param {string} options.direction - Possible values are 'in', 'out', and 'both'
     * @see mute
     * @example
     *
     * async function handler (request, response) {
     *   ...
     *   await response.unmute({direction: "out"});       // Will unmute only the "out" direction
     * }
     */
    unmute(options?: MuteOptions): Promise<void>;
    /**
     * Answer the communication channel. Before running any other verb you
     * must run the anwer command.
     *
     * @example
     *
     * async function handler (request, response) {
     *   await response.answer();
     *   ...
     * }
     */
    answer(): Promise<void>;
    /**
     * Terminates the communication channel.
     *
     * @example
     *
     * async function handler (request, response) {
     *   ...
     *   await response.hangup();
     * }
     */
    hangup(): Promise<void>;
    /**
     * Records the current channel and uploads the file to the storage subsystem.
     *
     * @param {RecordOptions} options - optional parameters to alter the command's normal
     * behavior
     * @param {number} options.maxDuration - Maximum duration of the recording, in seconds. Use `0` for no limit
     * @param {number} options.maxSilence - Maximum duration of silence, in seconds. Use `0` for no limit
     * @param {boolean} options.beep - Play beep when recording begins
     * @param {string} options.finishOnKey - DTMF input to terminate recording
     * @return {Promise<RecordResult>} Returns useful information such as the duration of the recording, etc.
     * @example
     *
     * async function handler (request, response) {
     *   await response.answer();;
     *   const result = await response.record({finishOnKey: "#"});
     *   console.log("recording result: " + JSON.stringify(result))     // recording result: { duration: 30 ...}
     * }
     */
    record(options: RecordOptions): Promise<RecordResult>;
    openMediaPipe(): Promise<void>;
    closeMediaPipe(): Promise<void>;
}
