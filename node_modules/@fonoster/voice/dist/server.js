"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const tracer_1 = require("./tracer");
const utils_1 = require("./utils");
const voice_1 = __importDefault(require("./voice"));
const logger_1 = __importDefault(require("@fonoster/logger"));
const express_1 = __importDefault(require("express"));
const os_1 = __importDefault(require("os"));
const pubsub_js_1 = __importDefault(require("pubsub-js"));
const merge = require("deepmerge");
const app = (0, express_1.default)();
app.use(express_1.default.json());
require("express-ws")(app);
const defaultServerConfig = {
    base: "/",
    port: 3000,
    bind: "0.0.0.0",
    pathToFiles: os_1.default.tmpdir(),
    otlSpanExporters: []
};
class VoiceServer {
    constructor(config = defaultServerConfig) {
        this.config = merge(defaultServerConfig, config);
        this.init();
        this.plugins = {};
    }
    /**
     * Add tts or asr plugin.
     *
     * @param plugin
     */
    use(plugin) {
        // Note: We only support registering one plugin per type
        this.plugins[plugin.getType()] = plugin;
    }
    listen(handler, port = this.config.port) {
        app.get(path_1.posix.join(this.config.base, "/sounds/:file"), (req, res) => (0, utils_1.serveFiles)(this.config)(req, res));
        // Alias path for sounds
        app.get(path_1.posix.join(this.config.base, "/tts/:file"), (req, res) => (0, utils_1.serveFiles)(this.config)(req, res));
        app.get("/ping", (req, res) => {
            res.send("pong");
        });
        app.post(path_1.posix.join(this.config.base), async (req, res) => {
            this.voiceTracer = new tracer_1.VoiceTracer(this.config.otlSpanExporters);
            this.voiceTracer.init();
            const response = new voice_1.default(req.body, this.voiceTracer);
            response.plugins = this.plugins;
            handler(req.body, response);
            res.end();
        });
        logger_1.default.info(`starting voice server @ ${this.config.bind}, port=${this.config.port}, path=${this.config.base}`);
        app.listen(port, this.config.bind);
    }
    init() {
        logger_1.default.info("initializing voice server");
        app.ws(this.config.base, (ws) => {
            ws.on("message", (msg) => {
                if (Buffer.isBuffer(msg)) {
                    // Session ids will always be 12 or 13 digits long)
                    const numDigits = 2;
                    const idLength = parseInt(msg.toString("utf-8", 0, numDigits));
                    const sessionId = msg.toString("utf-8", 2, idLength + numDigits);
                    const mediaData = msg.slice(idLength + numDigits);
                    pubsub_js_1.default.publish(`ReceivingMedia.${sessionId}`, mediaData);
                }
                else {
                    const event = JSON.parse(msg);
                    if (event.type === "PlaybackFinished") {
                        pubsub_js_1.default.publish(`${event.type}.${event.data.playbackId}`, event);
                    }
                    else if (event.type === "RecordingFinished" ||
                        event.type === "RecordingFailed") {
                        pubsub_js_1.default.publish(`${event.type}.${event.data.name}`, event);
                    }
                    else {
                        pubsub_js_1.default.publish(`${event.type}.${event.sessionId}`, event);
                    }
                    logger_1.default.verbose(`@fonoster/voice received event [${JSON.stringify(event, null, " ")}]`);
                }
            }).on("error", console.error);
        });
    }
}
exports.default = VoiceServer;
