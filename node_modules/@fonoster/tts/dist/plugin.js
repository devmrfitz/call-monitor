"use strict";
/*
 * Copyright (C) 2023 by Fonoster Inc (https://fonoster.com)
 * http://github.com/fonoster/fonoster
 *
 * This file is part of Fonoster
 *
 * Licensed under the MIT License (the "License");
 * you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    https://opensource.org/licenses/MIT
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@fonoster/common");
const utils_1 = require("./utils");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
class AbstractTTS extends common_1.Plugin {
    config;
    constructor(type, name, config) {
        super(type, name);
        this.config = config;
        this.config.path = config.path ? config.path : os_1.default.tmpdir();
    }
    /**
     * @inherit
     * @deprecated
     */
    async synthetize(text, options = {}) {
        return await this.synthesize(text, options);
    }
    /**
     * @inherit
     */
    async synthesize(text, options = {}) {
        const filename = (0, utils_1.computeFilename)(text, options, "sln24");
        const pathToFile = path_1.default.join(this.config.path, filename);
        if (!fs_1.default.existsSync(pathToFile)) {
            return await this.synthesizeSpeech(text, options, filename, pathToFile);
        }
        return { filename, pathToFile };
    }
}
exports.default = AbstractTTS;
