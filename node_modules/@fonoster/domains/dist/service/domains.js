"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DomainsService = exports.default = void 0;
const domains_pb_1 = require("./protos/domains_pb");
const common_pb_1 = require("./protos/common_pb");
const domains_grpc_pb_1 = require("./protos/domains_grpc_pb");
Object.defineProperty(exports, "DomainsService", { enumerable: true, get: function () { return domains_grpc_pb_1.DomainsService; } });
const core_1 = require("@fonoster/core");
const decoder_1 = __importDefault(require("./decoder"));
const decoder_2 = __importDefault(require("./decoder"));
const is_valid_domain_1 = __importDefault(require("is-valid-domain"));
const envs_1 = require("../envs");
class DomainsServer {
    async listDomains(call, callback) {
        const result = await core_1.ResourceServer.listResources(core_1.Kind.DOMAIN, call);
        const response = new domains_pb_1.ListDomainsResponse();
        if (result && result.resources) {
            const domains = result.resources.map((resource) => (0, decoder_2.default)(resource));
            response.setNextPageToken(result.nextPageToken + "");
            response.setDomainsList(domains);
        }
        callback(null, response);
    }
    async createDomain(call, callback) {
        const request = call.request;
        const domainUri = envs_1.APISERVER_GLOBAL_SIP_DOMAIN
            ? `${request.getDomainUri()}.${envs_1.APISERVER_GLOBAL_SIP_DOMAIN}`
            : request.getDomainUri();
        if ((0, is_valid_domain_1.default)(domainUri) == false) {
            callback(new Error(`Domain URI '${domainUri}' is not a valid domain`), null);
            return;
        }
        if (request.getEgressNumberRef() && !request.getEgressRule()) {
            callback(new Error("Egress Rule can't be null"), null);
            return;
        }
        try {
            const resource = new core_1.ResourceBuilder(core_1.Kind.DOMAIN, request.getName(), null)
                .withDomainUri(domainUri)
                .withEgressPolicy(request.getEgressRule(), request.getEgressNumberRef())
                .withACL(request.getAccessAllowList(), request.getAccessDenyList())
                .withMetadata({ accessKeyId: (0, core_1.getAccessKeyId)(call) })
                .build();
            const response = await (0, core_1.createResource)(resource);
            callback(null, (0, decoder_1.default)(response));
        }
        catch (e) {
            callback(e, null);
        }
    }
    async updateDomain(call, callback) {
        const request = call.request;
        if (request.getEgressNumberRef() && !request.getEgressRule()) {
            callback(new Error("Egress Rule can't be null"), null);
            return;
        }
        try {
            const domain = (await core_1.ResourceServer.getResource(core_1.Kind.DOMAIN, call));
            console.log("test-> " + domain);
            const resource = new core_1.ResourceBuilder(core_1.Kind.DOMAIN, request.getName(), request.getRef())
                .withMetadata({
                createdOn: domain.metadata.createdOn
            })
                .withEgressPolicy(request.getEgressRule(), request.getEgressNumberRef())
                .withACL(request.getAccessAllowList(), request.getAccessDenyList())
                .build();
            const result = await (0, core_1.updateResource)({
                resource,
                accessKeyId: (0, core_1.getAccessKeyId)(call)
            });
            callback(null, (0, decoder_2.default)(result));
        }
        catch (e) {
            callback(e, null);
        }
    }
    async getDomain(call, callback) {
        try {
            const result = await core_1.ResourceServer.getResource(core_1.Kind.DOMAIN, call);
            callback(null, (0, decoder_2.default)(result));
        }
        catch (e) {
            callback(e, null);
        }
    }
    async deleteDomain(call, callback) {
        try {
            await core_1.ResourceServer.deleteResource(core_1.Kind.DOMAIN, call);
            callback(null, new common_pb_1.Empty());
        }
        catch (e) {
            callback(e, null);
        }
    }
}
exports.default = DomainsServer;
